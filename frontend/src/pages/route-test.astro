---
import Layout from '../layouts/Layout.astro';
import 'leaflet/dist/leaflet.css';
---

<style>
	.route-endpoint-marker {
		background: none !important;
		border: none !important;
	}
</style>

<Layout>
	<div class="p-6 max-w-6xl mx-auto space-y-4">
		<h1 class="text-2xl font-bold text-slate-900 dark:text-slate-100">
			Route Test – Oslo Bysykkel
		</h1>
		<p class="text-slate-600 dark:text-slate-400">
			Display fetched bicycle routes on the map. Select a route from the dropdown to view it. When both directions are available, both are shown (green = selected direction, blue = return). Arrows indicate travel direction.
		</p>

		<div class="flex flex-col sm:flex-row gap-4 items-start flex-wrap">
			<div class="flex items-center gap-2">
				<label
					for="route-select"
					class="text-sm font-medium text-slate-700 dark:text-slate-300"
				>
					Route:
				</label>
				<select
					id="route-select"
					class="px-3 py-2 rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 min-w-[280px]"
				>
					<option value="">— Select route —</option>
				</select>
			</div>
		</div>

		<div
			id="map-container"
			class="w-full h-[500px] rounded-lg overflow-hidden border border-slate-200 dark:border-slate-700"
		></div>
		<p id="status" class="text-sm text-slate-500 dark:text-slate-400">Loading…</p>

		<section
			id="route-info"
			class="rounded-lg border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-800/50 p-4 min-h-[80px] hidden"
		>
			<h2 class="text-sm font-semibold text-slate-700 dark:text-slate-300 mb-2">
				Trip info
			</h2>
			<div
				id="route-info-content"
				class="text-slate-600 dark:text-slate-400 text-sm space-y-1"
			></div>
		</section>

		<section class="mt-12 pt-8 border-t border-slate-200 dark:border-slate-700">
			<h2 class="text-xl font-semibold text-slate-900 dark:text-slate-100 mb-2">
				All routes
			</h2>
			<p class="text-slate-600 dark:text-slate-400 text-sm mb-4">
				All fetched routes displayed at once. Routes use alternating colors for visibility.
			</p>
			<div
				id="map-all-routes"
				class="w-full h-[500px] rounded-lg overflow-hidden border border-slate-200 dark:border-slate-700"
			></div>
		</section>

		<section class="mt-12 pt-8 border-t border-slate-200 dark:border-slate-700">
			<h2 class="text-xl font-semibold text-slate-900 dark:text-slate-100 mb-2">
				Route density
			</h2>
			<p class="text-slate-600 dark:text-slate-400 text-sm mb-4">
				Routes by trip count from <code class="text-xs bg-slate-200 dark:bg-slate-700 px-1 rounded">station_trip_counts.ipynb</code>. Choose total, year, or month; scroll the timeline in year/month modes.
			</p>
			<div
				id="density-controls"
				class="flex flex-wrap gap-6 items-end mb-4 p-4 rounded-lg border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-800/50"
			>
				<div class="flex flex-col gap-1">
					<label for="density-period-mode" class="text-sm font-medium text-slate-700 dark:text-slate-300">Period</label>
					<select
						id="density-period-mode"
						class="px-3 py-2 rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100"
					>
						<option value="total">Total</option>
						<option value="year">By year</option>
						<option value="month">By month</option>
					</select>
				</div>
				<div id="density-timeline-wrap" class="flex flex-col gap-1 hidden">
					<label for="density-timeline" class="text-sm font-medium text-slate-700 dark:text-slate-300">Timeline</label>
					<div class="flex items-center gap-3">
						<input
							id="density-timeline"
							type="range"
							min="0"
							max="1"
							step="1"
							value="0"
							class="flex-1 min-w-[200px]"
						/>
						<span id="density-timeline-label" class="text-sm font-medium text-slate-700 dark:text-slate-300 min-w-[100px]"></span>
					</div>
				</div>
				<div class="flex flex-col gap-1">
					<label for="density-opacity-min" class="text-sm font-medium text-slate-700 dark:text-slate-300">Min opacity</label>
					<input
						id="density-opacity-min"
						type="range"
						min="0"
						max="1"
						step="0.05"
						value="0.15"
						class="w-28"
					/>
					<span id="density-opacity-min-val" class="text-xs text-slate-500 dark:text-slate-400">0.15</span>
				</div>
				<div class="flex flex-col gap-1">
					<label for="density-opacity-max" class="text-sm font-medium text-slate-700 dark:text-slate-300">Max opacity</label>
					<input
						id="density-opacity-max"
						type="range"
						min="0"
						max="1"
						step="0.05"
						value="0.9"
						class="w-28"
					/>
					<span id="density-opacity-max-val" class="text-xs text-slate-500 dark:text-slate-400">0.9</span>
				</div>
				<div class="flex flex-col gap-1">
					<label for="density-min-trips" class="text-sm font-medium text-slate-700 dark:text-slate-300">Min trips (filter)</label>
					<input
						id="density-min-trips"
						type="number"
						min="0"
						value="0"
						class="px-3 py-2 rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 w-24"
					/>
					<span id="density-route-count" class="text-xs text-slate-500 dark:text-slate-400"></span>
				</div>
				<p id="density-trip-count-status" class="hidden w-full text-sm text-amber-600 dark:text-amber-400"></p>
			</div>
			<div
				id="map-route-density"
				class="w-full h-[500px] rounded-lg overflow-hidden border border-slate-200 dark:border-slate-700"
			></div>
		</section>
	</div>
</Layout>

<script>
	import { loadPreparedData, loadParquetData, loadIsochronesData } from '../data/load-prepared-data';
	import type { RoutesData, RouteData, RoutePairCount, RouteBinnedRow } from '../data/prepared-data-types';
	import type { IsochroneStation } from '../data/prepared-data-types';
	import { decodePolyline } from '../utils/decode-polyline';
	import { offsetPolyline } from '../utils/offset-polyline';
	import type { Map, LayerGroup } from 'leaflet';
	import * as d3 from 'd3';

	const base = import.meta.env.BASE_URL ?? '/';

	let map: Map | null = null;
	let stationDotsLayer: LayerGroup | null = null;
	let originMarkerLayer: LayerGroup | null = null;
	let destMarkerLayer: LayerGroup | null = null;
	const OSLO_CENTER: [number, number] = [59.92, 10.75];
	const DEFAULT_ZOOM = 13;
	const STATION_DOT_RADIUS = 6;
	const ARROW_COLOR = '#1a1a1a';
	const ROUTE_OFFSET_M = 12;
	const COLOR_FORWARD = '#22c55e';
	const COLOR_RETURN = '#3b82f6';
	const ALL_ROUTES_COLORS = [
		'#22c55e',
		'#3b82f6',
		'#f59e0b',
		'#8b5cf6',
		'#ec4899',
		'#06b6d4',
		'#ef4444',
	];

			function getBoundsForLayerGroup(
				L: typeof import('leaflet'),
				group: L.LayerGroup
			): L.LatLngBounds | null {
				const layers = group.getLayers();
				let bounds: L.LatLngBounds | null = null;
				for (const layer of layers) {
					const b = (layer as L.Polyline).getBounds?.();
					if (b?.isValid?.()) {
						if (!bounds) {
							bounds = L.latLngBounds(b.getSouthWest(), b.getNorthEast());
						} else {
							bounds.extend(b);
						}
					}
				}
				return bounds;
			}

			function addArrowDecorator(
		L: typeof import('leaflet'),
		layer: L.Polyline,
		group: L.LayerGroup,
		color = ARROW_COLOR
	) {
		try {
			const decorator = (L as any).polylineDecorator(layer, {
				patterns: [
					{
						offset: 0,
						repeat: 80,
						symbol: (L as any).Symbol.arrowHead({
							pixelSize: 12,
							polygon: true,
							pathOptions: {
								color,
								fillColor: color,
								fillOpacity: 1,
								weight: 1,
							},
						}),
					},
				],
			});
			decorator.addTo(group);
		} catch {
			// Plugin may not be loaded; skip arrows
		}
	}

	async function init() {
		const statusEl = document.getElementById('status');
		const selectEl = document.getElementById('route-select') as HTMLSelectElement;
		const mapEl = document.getElementById('map-container');
		const infoSection = document.getElementById('route-info');
		const infoContent = document.getElementById('route-info-content');
		if (!statusEl || !selectEl || !mapEl || !infoSection || !infoContent) return;

		const L = (await import('leaflet')).default;
		await import('leaflet-polylinedecorator');

		try {
			let stations: IsochroneStation[] = [];
			try {
				const { data } = await loadPreparedData<{ stations: IsochroneStation[] }>(
					'stations.json'
				);
				stations = data?.stations ?? [];
			} catch {
				const data = await loadIsochronesData();
				stations = data?.stations ?? [];
			}

			if (!stations.length) {
				statusEl.textContent =
					'No stations. Run stations_prepare.ipynb and npm run prepare:data.';
				return;
			}

			let routes: RouteData[] = [];
			try {
				const { data } = await loadPreparedData<RoutesData>('routes.json');
				routes = data?.routes ?? [];
				if (routes.length > 0) {
					console.log('[route-test] Loaded', routes.length, 'routes');
				}
			} catch (e) {
				console.warn('Routes load failed:', e);
			}

			const pairCountByKey = new Map<string, number>();
			const countByYear = new Map<string, Map<string, number>>();
			const countByMonth = new Map<string, Map<string, number>>();
			let yearsSorted: string[] = [];
			let monthsSorted: string[] = [];
			let yearsLoaded = false;
			let monthsLoaded = false;

			try {
				const rows = await loadParquetData<RoutePairCount>('routes/route_pair_counts.parquet');
				for (const r of rows) {
					const key = String(r.route_key ?? '').trim();
					pairCountByKey.set(key, Number(r.count));
				}
			} catch (e) {
				console.warn('Parquet load failed: routes/route_pair_counts.parquet', e);
			}

			async function ensureYearDataLoaded(): Promise<void> {
				if (yearsLoaded) return;
				try {
					const yearRows = await loadParquetData<RouteBinnedRow>('routes/route_by_year.parquet');
					for (const r of yearRows) {
						const key = String(r.route_key ?? '').trim();
						if (!countByYear.has(r.period)) countByYear.set(r.period, new Map());
						const m = countByYear.get(r.period)!;
						m.set(key, (m.get(key) ?? 0) + Number(r.count));
					}
					yearsSorted = [...countByYear.keys()].sort();
					yearsLoaded = true;
				} catch (e) {
					console.warn('Parquet load failed: routes/route_by_year.parquet', e);
				}
			}

			async function ensureMonthDataLoaded(): Promise<void> {
				if (monthsLoaded) return;
				try {
					const monthRows = await loadParquetData<RouteBinnedRow>('routes/route_by_month.parquet');
					for (const r of monthRows) {
						const key = String(r.route_key ?? '').trim();
						if (!countByMonth.has(r.period)) countByMonth.set(r.period, new Map());
						const m = countByMonth.get(r.period)!;
						m.set(key, (m.get(key) ?? 0) + Number(r.count));
					}
					monthsSorted = [...countByMonth.keys()].sort();
					monthsLoaded = true;
				} catch (e) {
					console.warn('Parquet load failed: routes/route_by_month.parquet', e);
				}
			}

			function routeKey(originId: string | number, destId: string | number): string {
				return `${String(originId).trim()}|${String(destId).trim()}`;
			}

			statusEl.textContent =
				routes.length === 0
					? 'No routes fetched yet. Run google_routes_test.ipynb and npm run prepare:data.'
					: '';

			const stationById = new Map(stations.map((s) => [s.id, s]));
			const routeByKey = new Map<string, RouteData>();
			for (const r of routes) {
				if (r.encodedPolyline) {
					routeByKey.set(routeKey(r.origin_id, r.dest_id), r);
				}
			}

			for (const r of routes) {
				const origin = stationById.get(r.origin_id);
				const dest = stationById.get(r.dest_id);
				const label = origin && dest
					? `${origin.name} → ${dest.name}`
					: `${r.origin_id} → ${r.dest_id}`;
				const opt = document.createElement('option');
				opt.value = routeKey(r.origin_id, r.dest_id);
				opt.textContent = label;
				selectEl.appendChild(opt);
			}

			map = L.map(mapEl).setView(OSLO_CENTER, DEFAULT_ZOOM);
			L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
				attribution:
					'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
			}).addTo(map);

			map.createPane('routePane');
			map.getPane('routePane')!.style.zIndex = '400';
			map.createPane('stationMarkersPane');
			map.getPane('stationMarkersPane')!.style.zIndex = '450';
			map.createPane('endpointsPane');
			map.getPane('endpointsPane')!.style.zIndex = '600';

			const routeGroup = L.layerGroup().addTo(map);
			stationDotsLayer = L.layerGroup().addTo(map);
			originMarkerLayer = L.layerGroup().addTo(map);
			destMarkerLayer = L.layerGroup().addTo(map);

			for (const s of stations) {
				const circle = L.circleMarker([s.lat, s.lon], {
					pane: 'stationMarkersPane',
					radius: STATION_DOT_RADIUS,
					fillColor: '#3b82f6',
					fillOpacity: 0.7,
					color: '#1e40af',
					weight: 1.5,
				});
				circle.bindTooltip(s.name, { permanent: false, direction: 'top' });
				circle.addTo(stationDotsLayer);
			}

			function formatDuration(sec: number | null) {
				return sec != null ? `${Math.round(sec / 60)} min` : 'N/A';
			}
			function formatDistance(m: number | null) {
				return m != null ? `${(m / 1000).toFixed(2)} km` : 'N/A';
			}

			function addRoutePolyline(
				route: RouteData,
				color: string,
				offsetM: number,
				originName: string,
				destName: string
			) {
				if (!route?.encodedPolyline) return;
				const points = decodePolyline(route.encodedPolyline).map(
					([lat, lng]) => [lat, lng] as [number, number]
				);
				const latlngs =
					offsetM !== 0 ? offsetPolyline(points, offsetM) : points;
				const poly = L.polyline(latlngs, {
					pane: 'routePane',
					color,
					weight: 5,
					opacity: 0.8,
				}).addTo(routeGroup);
				poly.on('mouseover', () => poly.setStyle({ weight: 8, opacity: 1 }));
				poly.on('mouseout', () => poly.setStyle({ weight: 5, opacity: 0.8 }));
				addArrowDecorator(L, poly, routeGroup, color);
				return poly;
			}

			function showRoute(selectedKey: string) {
				routeGroup.clearLayers();
				originMarkerLayer?.clearLayers();
				destMarkerLayer?.clearLayers();

				const [originId, destId] = selectedKey.split('|');
				const route = routeByKey.get(selectedKey);
				if (!route?.encodedPolyline) return;

				const origin = stationById.get(originId);
				const dest = stationById.get(destId);
				const originName = origin?.name ?? originId;
				const destName = dest?.name ?? destId;

				const returnKey = routeKey(destId, originId);
				const returnRoute = routeByKey.get(returnKey);

				addRoutePolyline(route, COLOR_FORWARD, 0, originName, destName);
				if (returnRoute) {
					addRoutePolyline(
						returnRoute,
						COLOR_RETURN,
						ROUTE_OFFSET_M,
						destName,
						originName
					);
				}

				const bounds = getBoundsForLayerGroup(L, routeGroup);
				if (bounds?.isValid()) map?.fitBounds(bounds, { padding: [30, 30] });

				const points = decodePolyline(route.encodedPolyline).map(
					([lat, lng]) => [lat, lng] as [number, number]
				);
				if (points.length > 0) {
					const originIcon = L.divIcon({
						className: 'route-endpoint-marker',
						html: '<div style="width:24px;height:24px;border-radius:50%;background:#22c55e;border:3px solid white;box-shadow:0 1px 3px rgba(0,0,0,0.4);"></div>',
						iconSize: [24, 24],
						iconAnchor: [12, 12],
					});
					const destIcon = L.divIcon({
						className: 'route-endpoint-marker',
						html: '<div style="width:24px;height:24px;border-radius:50%;background:#3b82f6;border:3px solid white;box-shadow:0 1px 3px rgba(0,0,0,0.4);"></div>',
						iconSize: [24, 24],
						iconAnchor: [12, 12],
					});
					L.marker(points[0], { icon: originIcon, pane: 'endpointsPane' })
						.bindPopup(`Origin: ${originName}`)
						.addTo(originMarkerLayer!);
					L.marker(points[points.length - 1], { icon: destIcon, pane: 'endpointsPane' })
						.bindPopup(`Destination: ${destName}`)
						.addTo(destMarkerLayer!);
				}

				infoSection.classList.remove('hidden');
				const tripCount = pairCountByKey.get(selectedKey);
				let html = `<p><strong>${originName}</strong> ↔ <strong>${destName}</strong></p>`;
				if (tripCount != null) {
					html += `<p class="mt-2">Total trips: <strong>${Number(tripCount).toLocaleString()}</strong></p>`;
				}
				html += `<p class="mt-2"><strong>${originName}</strong> → ${destName}: ${formatDuration(route.duration_sec)} · ${formatDistance(route.distance_m)}</p>`;
				if (returnRoute) {
					html += `<p><strong>${destName}</strong> → ${originName}: ${formatDuration(returnRoute.duration_sec)} · ${formatDistance(returnRoute.distance_m)}</p>`;
				} else {
					html += `<p class="text-amber-600 dark:text-amber-400 italic">Return route (${destName} → ${originName}) not yet available.</p>`;
				}
				infoContent.innerHTML = html;
			}

			selectEl.addEventListener('change', () => {
				const val = selectEl.value;
				if (val) showRoute(val);
			});

			if (routes.length > 0) {
				selectEl.value = routeKey(routes[0].origin_id, routes[0].dest_id);
				showRoute(selectEl.value);
			}

			// All-routes map
			const mapAllEl = document.getElementById('map-all-routes');
			if (mapAllEl && routes.length > 0) {
				const mapAll = L.map(mapAllEl).setView(OSLO_CENTER, DEFAULT_ZOOM);
				L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					attribution:
						'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
				}).addTo(mapAll);

				mapAll.createPane('allRoutePane');
				mapAll.getPane('allRoutePane')!.style.zIndex = '400';
				mapAll.createPane('allStationPane');
				mapAll.getPane('allStationPane')!.style.zIndex = '450';

				const allRouteGroup = L.layerGroup().addTo(mapAll);
				const allStationLayer = L.layerGroup().addTo(mapAll);

				for (const s of stations) {
					const circle = L.circleMarker([s.lat, s.lon], {
						pane: 'allStationPane',
						radius: 4,
						fillColor: '#64748b',
						fillOpacity: 0.6,
						color: '#475569',
						weight: 1,
					});
					circle.addTo(allStationLayer);
				}

				let allBounds: L.LatLngBounds | null = null;
				for (let i = 0; i < routes.length; i++) {
					const r = routes[i];
					if (!r?.encodedPolyline) continue;
					const points = decodePolyline(r.encodedPolyline).map(
						([lat, lng]) => [lat, lng] as [number, number]
					);
					const color = ALL_ROUTES_COLORS[i % ALL_ROUTES_COLORS.length];
					const poly = L.polyline(points, {
						pane: 'allRoutePane',
						color,
						weight: 3,
						opacity: 0.7,
					}).addTo(allRouteGroup);
					poly.on('mouseover', () => poly.setStyle({ weight: 5, opacity: 1 }));
					poly.on('mouseout', () => poly.setStyle({ weight: 3, opacity: 0.7 }));
					const origin = stationById.get(r.origin_id);
					const dest = stationById.get(r.dest_id);
					const label = origin && dest
						? `${origin.name} → ${dest.name}`
						: `${r.origin_id} → ${r.dest_id}`;
					poly.bindTooltip(label, { permanent: false, direction: 'top' });
					const b = poly.getBounds();
					if (b?.isValid?.()) {
						if (!allBounds) allBounds = L.latLngBounds(b.getSouthWest(), b.getNorthEast());
						else allBounds.extend(b);
					}
				}
				if (allBounds?.isValid()) {
					mapAll.fitBounds(allBounds, { padding: [40, 40] });
				}
				// Fix map size: container may have 0 height at init when below the fold
				const fixMapSize = () => {
					mapAll.invalidateSize();
					const allRoutesSection = mapAllEl.closest('section');
					if (allRoutesSection) {
						const obs = new IntersectionObserver(
							([entry]) => {
								if (entry?.isIntersecting) mapAll.invalidateSize();
							},
							{ threshold: 0.1 }
						);
						obs.observe(allRoutesSection);
					}
				};
				requestAnimationFrame(() => requestAnimationFrame(fixMapSize));
			}

			// Route density map (opacity by trip count; single color; total/year/month + timeline)
			const DENSITY_COLOR = '#2563eb';
			const mapDensityEl = document.getElementById('map-route-density');
			const densityPeriodMode = document.getElementById('density-period-mode') as HTMLSelectElement;
			const densityTimelineWrap = document.getElementById('density-timeline-wrap');
			const densityTimeline = document.getElementById('density-timeline') as HTMLInputElement;
			const densityTimelineLabel = document.getElementById('density-timeline-label');
			const densityOpacityMin = document.getElementById('density-opacity-min') as HTMLInputElement;
			const densityOpacityMax = document.getElementById('density-opacity-max') as HTMLInputElement;
			const densityMinTrips = document.getElementById('density-min-trips') as HTMLInputElement;
			const densityOpacityMinVal = document.getElementById('density-opacity-min-val');
			const densityOpacityMaxVal = document.getElementById('density-opacity-max-val');
			const densityRouteCount = document.getElementById('density-route-count');
			const densityTripCountStatus = document.getElementById('density-trip-count-status');

			const hasTripCountData = pairCountByKey.size > 0;
			if (densityTripCountStatus && !hasTripCountData) {
				densityTripCountStatus.classList.remove('hidden');
				densityTripCountStatus.textContent = 'Trip counts not available. Run station_trip_counts.ipynb and npm run prepare:data.';
			}

			function getCountForRoute(
				key: string,
				periodMode: string,
				period: string
			): number {
				const raw =
					periodMode === 'total' ? pairCountByKey.get(key)
					: periodMode === 'year' ? countByYear.get(period)?.get(key)
					: periodMode === 'month' ? countByMonth.get(period)?.get(key)
					: undefined;
				return Number(raw) || 0;
			}

			function updateTimelineUI() {
				const mode = densityPeriodMode?.value ?? 'total';
				if (mode === 'total') {
					densityTimelineWrap?.classList.add('hidden');
					return;
				}
				densityTimelineWrap?.classList.remove('hidden');
				const periods = mode === 'year' ? yearsSorted : monthsSorted;
				if (periods.length === 0) {
					if (densityTimelineLabel) densityTimelineLabel.textContent = 'No data';
					return;
				}
				if (densityTimeline) {
					densityTimeline.max = String(Math.max(0, periods.length - 1));
					densityTimeline.step = '1';
					densityTimeline.value = String(Math.min(parseInt(densityTimeline.value || '0', 10), periods.length - 1));
					const idx = parseInt(densityTimeline.value, 10);
					const period = periods[idx] ?? periods[0];
					if (densityTimelineLabel) densityTimelineLabel.textContent = period;
				}
			}

			async function handleDensityControlChange() {
				const mode = densityPeriodMode?.value ?? 'total';
				if (mode === 'year') {
					if (densityTimelineLabel) densityTimelineLabel.textContent = 'Loading…';
					densityTimelineWrap?.classList.remove('hidden');
					await ensureYearDataLoaded();
				} else if (mode === 'month') {
					if (densityTimelineLabel) densityTimelineLabel.textContent = 'Loading…';
					densityTimelineWrap?.classList.remove('hidden');
					await ensureMonthDataLoaded();
				}
				updateTimelineUI();
				renderDensityMap(true);
			}

			function getDensitySettings() {
				const minOpacity = parseFloat(densityOpacityMin?.value ?? '0.15') || 0.15;
				const maxOpacity = parseFloat(densityOpacityMax?.value ?? '0.9') || 0.9;
				const minTrips = parseInt(densityMinTrips?.value ?? '0', 10) || 0;
				const periodMode = densityPeriodMode?.value ?? 'total';
				const periods = periodMode === 'year' ? yearsSorted : periodMode === 'month' ? monthsSorted : [];
				const idx = Math.min(parseInt(densityTimeline?.value ?? '0', 10), Math.max(0, periods.length - 1));
				const period = periods[idx] ?? periods[0] ?? '';
				return { minOpacity, maxOpacity, minTrips, periodMode, period };
			}

			function renderDensityMap(fitBoundsNow = false) {
				if (!mapDensityEl || routes.length === 0) return;
				const { minOpacity, maxOpacity, minTrips, periodMode, period } = getDensitySettings();

				const routesWithCount = routes
					.map((r) => {
						const key = routeKey(r.origin_id, r.dest_id);
						const count = getCountForRoute(key, periodMode, period);
						return { route: r, key, count };
					})
					.filter(({ count }) => count >= minTrips);

				const counts = routesWithCount.map((x) => x.count);
				const countMin = counts.length ? Math.min(...counts) : 0;
				const countMax = counts.length ? Math.max(...counts) : 1;
				const countDomain = countMax > countMin ? [countMin, countMax] : [0, 1];
				const opacityScale = d3.scaleLinear().domain(countDomain).range([minOpacity, maxOpacity]);

				if (densityRouteCount) {
					densityRouteCount.textContent = `${routesWithCount.length} routes shown`;
				}

				densityRouteGroup?.clearLayers();

				let densityBounds: L.LatLngBounds | null = null;
				for (const { route: r, key, count } of routesWithCount) {
					if (!r?.encodedPolyline) continue;
					const points = decodePolyline(r.encodedPolyline).map(
						([lat, lng]) => [lat, lng] as [number, number]
					);
					const opacity = opacityScale(count);
					const poly = L.polyline(points, {
						pane: 'densityRoutePane',
						color: DENSITY_COLOR,
						weight: 4,
						opacity,
					}).addTo(densityRouteGroup!);
					poly.on('mouseover', () => poly.setStyle({ weight: 6, opacity: Math.min(1, opacity + 0.2) }));
					poly.on('mouseout', () => poly.setStyle({ weight: 4, opacity }));
					const origin = stationById.get(r.origin_id);
					const dest = stationById.get(r.dest_id);
					const label = origin && dest
						? `${origin.name} → ${dest.name} (${count.toLocaleString()} trips)`
						: `${r.origin_id} → ${r.dest_id} (${count.toLocaleString()} trips)`;
					poly.bindTooltip(label, { permanent: false, direction: 'top' });
					const b = poly.getBounds();
					if (b?.isValid?.()) {
						if (!densityBounds) densityBounds = L.latLngBounds(b.getSouthWest(), b.getNorthEast());
						else densityBounds.extend(b);
					}
				}
				if (fitBoundsNow && densityBounds?.isValid()) {
					mapDensity!.fitBounds(densityBounds, { padding: [40, 40] });
				}
			}

			let mapDensity: L.Map | null = null;
			let densityRouteGroup: L.LayerGroup | null = null;

			if (mapDensityEl && routes.length > 0) {
				mapDensity = L.map(mapDensityEl).setView(OSLO_CENTER, DEFAULT_ZOOM);
				L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					attribution:
						'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
				}).addTo(mapDensity);

				mapDensity.createPane('densityRoutePane');
				mapDensity.getPane('densityRoutePane')!.style.zIndex = '400';
				mapDensity.createPane('densityStationPane');
				mapDensity.getPane('densityStationPane')!.style.zIndex = '450';

				densityRouteGroup = L.layerGroup().addTo(mapDensity);
				const densityStationLayer = L.layerGroup().addTo(mapDensity);

				for (const s of stations) {
					const circle = L.circleMarker([s.lat, s.lon], {
						pane: 'densityStationPane',
						radius: 4,
						fillColor: '#64748b',
						fillOpacity: 0.6,
						color: '#475569',
						weight: 1,
					});
					circle.addTo(densityStationLayer);
				}

				updateTimelineUI();
				renderDensityMap(true);

				// Fix map size: container may have 0 height at init when below the fold
				requestAnimationFrame(() => requestAnimationFrame(() => mapDensity?.invalidateSize()));

				densityPeriodMode?.addEventListener('change', () => void handleDensityControlChange());
				[densityTimeline, densityOpacityMin, densityOpacityMax, densityMinTrips].forEach((el) => {
					el?.addEventListener('change', () => {
						updateTimelineUI();
						renderDensityMap(true);
					});
					el?.addEventListener('input', () => {
						updateTimelineUI();
						renderDensityMap(false);
						if (el === densityOpacityMin && densityOpacityMinVal) densityOpacityMinVal.textContent = densityOpacityMin.value;
						if (el === densityOpacityMax && densityOpacityMaxVal) densityOpacityMaxVal.textContent = densityOpacityMax.value;
					});
				});
				if (densityOpacityMinVal) densityOpacityMinVal.textContent = densityOpacityMin?.value ?? '0.15';
				if (densityOpacityMaxVal) densityOpacityMaxVal.textContent = densityOpacityMax?.value ?? '0.9';
				const densitySection = mapDensityEl.closest('section');
				if (densitySection && mapDensity) {
					const obs = new IntersectionObserver(
						([entry]) => {
							if (entry?.isIntersecting) mapDensity?.invalidateSize();
						},
						{ threshold: 0.1 }
					);
					obs.observe(densitySection);
				}
			}
		} catch (err) {
			statusEl.textContent = `Failed to load: ${err instanceof Error ? err.message : String(err)}`;
		}
	}

	init();
</script>
