---
import Layout from '../layouts/Layout.astro';
import 'leaflet/dist/leaflet.css';
---

<Layout>
	<div class="p-6 max-w-6xl mx-auto space-y-4">
		<h1 class="text-2xl font-bold text-slate-900 dark:text-slate-100">
			Route Test – Oslo Bysykkel
		</h1>
		<p class="text-slate-600 dark:text-slate-400">
			Display fetched bicycle routes on the map. Select a route from the dropdown to view it.
		</p>

		<div class="flex flex-col sm:flex-row gap-4 items-start flex-wrap">
			<div class="flex items-center gap-2">
				<label
					for="route-select"
					class="text-sm font-medium text-slate-700 dark:text-slate-300"
				>
					Route:
				</label>
				<select
					id="route-select"
					class="px-3 py-2 rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 min-w-[280px]"
				>
					<option value="">— Select route —</option>
				</select>
			</div>
		</div>

		<div
			id="map-container"
			class="w-full h-[500px] rounded-lg overflow-hidden border border-slate-200 dark:border-slate-700"
		></div>
		<p id="status" class="text-sm text-slate-500 dark:text-slate-400">Loading…</p>

		<section
			id="route-info"
			class="rounded-lg border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-800/50 p-4 min-h-[80px] hidden"
		>
			<h2 class="text-sm font-semibold text-slate-700 dark:text-slate-300 mb-2">
				Trip info
			</h2>
			<div
				id="route-info-content"
				class="text-slate-600 dark:text-slate-400 text-sm space-y-1"
			></div>
		</section>
	</div>
</Layout>

<script>
	import { loadPreparedData } from '../data/load-prepared-data';
	import type { RoutesData, RouteData } from '../data/prepared-data-types';
	import type { IsochronesData, IsochroneStation } from '../data/prepared-data-types';
	import { decodePolyline } from '../utils/decode-polyline';

	const base = import.meta.env.BASE_URL ?? '/';

	const OSLO_CENTER: [number, number] = [59.92, 10.75];
	const DEFAULT_ZOOM = 13;
	const STATION_DOT_RADIUS = 6;

	let map: L.Map | null = null;
	let routeLayer: L.Polyline | null = null;
	let stationDotsLayer: L.LayerGroup | null = null;
	let originMarkerLayer: L.LayerGroup | null = null;
	let destMarkerLayer: L.LayerGroup | null = null;

	async function init() {
		const statusEl = document.getElementById('status');
		const selectEl = document.getElementById('route-select') as HTMLSelectElement;
		const mapEl = document.getElementById('map-container');
		const infoSection = document.getElementById('route-info');
		const infoContent = document.getElementById('route-info-content');
		if (!statusEl || !selectEl || !mapEl || !infoSection || !infoContent) return;

		const L = (await import('leaflet')).default;

		try {
			// Load stations (prefer stations.json, fallback to isochrones)
			let stations: IsochroneStation[] = [];
			try {
				const { data } = await loadPreparedData<{ stations: IsochroneStation[] }>(
					'stations.json'
				);
				stations = data?.stations ?? [];
			} catch {
				const { data } = await loadPreparedData<IsochronesData>('isochrones.json');
				stations = data?.stations ?? [];
			}

			if (!stations.length) {
				statusEl.textContent =
					'No stations. Run stations_prepare.ipynb and npm run prepare:data.';
				return;
			}

			// Load routes (prefer medium, fallback to slim)
			let routes: RouteData[] = [];
			try {
				const { data } = await loadPreparedData<RoutesData>('routes_medium.json');
				routes = data?.routes ?? [];
			} catch {
				try {
					const { data } = await loadPreparedData<RoutesData>('routes.json');
					routes = data?.routes ?? [];
				} catch {
					// routes may not exist if no routes fetched yet
				}
			}

			statusEl.textContent =
				routes.length === 0
					? 'No routes fetched yet. Run google_routes_test.ipynb and npm run prepare:data.'
					: '';

			const stationById = new Map(stations.map((s) => [s.id, s]));

			// Populate route dropdown
			for (const r of routes) {
				const origin = stationById.get(r.origin_id);
				const dest = stationById.get(r.dest_id);
				const label = origin && dest
					? `${origin.name} → ${dest.name}`
					: `${r.origin_id} → ${r.dest_id}`;
				const opt = document.createElement('option');
				opt.value = `${r.origin_id}|${r.dest_id}`;
				opt.textContent = label;
				selectEl.appendChild(opt);
			}

			// Init map
			map = L.map(mapEl).setView(OSLO_CENTER, DEFAULT_ZOOM);
			L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
				attribution:
					'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
			}).addTo(map);

			map.createPane('routePane');
			map.getPane('routePane')!.style.zIndex = '400';
			map.createPane('stationMarkersPane');
			map.getPane('stationMarkersPane')!.style.zIndex = '450';
			map.createPane('endpointsPane');
			map.getPane('endpointsPane')!.style.zIndex = '600';

			const routeGroup = L.layerGroup().addTo(map);
			stationDotsLayer = L.layerGroup().addTo(map);
			originMarkerLayer = L.layerGroup().addTo(map);
			destMarkerLayer = L.layerGroup().addTo(map);

			// Station dots
			for (const s of stations) {
				const circle = L.circleMarker([s.lat, s.lon], {
					pane: 'stationMarkersPane',
					radius: STATION_DOT_RADIUS,
					fillColor: '#3b82f6',
					fillOpacity: 0.7,
					color: '#1e40af',
					weight: 1.5,
				});
				circle.bindTooltip(s.name, { permanent: false, direction: 'top' });
				circle.addTo(stationDotsLayer);
			}

			function showRoute(routeKey: string) {
				routeGroup.clearLayers();
				originMarkerLayer?.clearLayers();
				destMarkerLayer?.clearLayers();
				if (routeLayer) routeLayer = null;

				const [originId, destId] = routeKey.split('|');
				const route = routes.find(
					(r) => r.origin_id === originId && r.dest_id === destId
				);
				if (!route) return;

				const origin = stationById.get(originId);
				const dest = stationById.get(destId);

				// Derive polyline: medium = legs, slim = route encodedPolyline
				let latlngs: [number, number][];
				if (route.legs?.length) {
					latlngs = route.legs.flatMap((l) =>
						decodePolyline(l.encodedPolyline).map(([lat, lng]) => [lat, lng] as [number, number])
					);
				} else if (route.encodedPolyline) {
					latlngs = decodePolyline(route.encodedPolyline).map(
						([lat, lng]) => [lat, lng] as [number, number]
					);
				} else {
					return;
				}

				routeLayer = L.polyline(latlngs, {
					pane: 'routePane',
					color: '#22c55e',
					weight: 5,
					opacity: 0.8,
				}).addTo(routeGroup);

				// Fit map to route with padding
				map?.fitBounds(routeLayer.getBounds(), { padding: [30, 30] });

				// Origin/dest markers: medium = route coords, slim = first/last decoded point
				const originPoint: [number, number] | null = route.start_lat != null && route.start_lon != null
					? [route.start_lat, route.start_lon]
					: latlngs.length > 0
						? latlngs[0]
						: null;
				const destPoint: [number, number] | null = route.legs?.length
					? (() => {
							const last = route.legs![route.legs!.length - 1];
							return last.end_lat != null && last.end_lon != null
								? [last.end_lat, last.end_lon]
								: latlngs.length > 0
									? latlngs[latlngs.length - 1]
									: null;
						})()
					: latlngs.length > 0
						? latlngs[latlngs.length - 1]
						: null;

				if (originPoint) {
					L.marker(originPoint, { pane: 'endpointsPane' })
						.bindPopup(`Origin: ${origin?.name ?? originId}`)
						.addTo(originMarkerLayer!);
				}
				if (destPoint) {
					L.marker(destPoint, { pane: 'endpointsPane' })
						.bindPopup(`Destination: ${dest?.name ?? destId}`)
						.addTo(destMarkerLayer!);
				}

				// Trip info
				infoSection.classList.remove('hidden');
				const duration =
					route.duration_sec != null
						? `${Math.round(route.duration_sec / 60)} min`
						: 'N/A';
				const distance =
					route.distance_m != null
						? `${(route.distance_m / 1000).toFixed(2)} km`
						: 'N/A';
				infoContent.innerHTML = `
					<p><strong>${origin?.name ?? originId}</strong> → <strong>${dest?.name ?? destId}</strong></p>
					<p>Duration: ${duration}</p>
					<p>Distance: ${distance}</p>
				`;
			}

			selectEl.addEventListener('change', () => {
				const val = selectEl.value;
				if (val) showRoute(val);
			});

			// Select first route by default
			if (routes.length > 0) {
				selectEl.value = `${routes[0].origin_id}|${routes[0].dest_id}`;
				showRoute(selectEl.value);
			}
		} catch (err) {
			statusEl.textContent = `Failed to load: ${err instanceof Error ? err.message : String(err)}`;
		}
	}

	init();
</script>
