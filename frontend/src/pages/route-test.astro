---
import Layout from '../layouts/Layout.astro';
import 'leaflet/dist/leaflet.css';
---

<Layout>
	<div class="p-6 max-w-6xl mx-auto space-y-4">
		<h1 class="text-2xl font-bold text-slate-900 dark:text-slate-100">
			Route Test – Oslo Bysykkel
		</h1>
		<p class="text-slate-600 dark:text-slate-400">
			Display fetched bicycle routes on the map. Select a route from the dropdown to view it. When both directions are available, both are shown (green = selected direction, blue = return). Arrows indicate travel direction.
		</p>

		<div class="flex flex-col sm:flex-row gap-4 items-start flex-wrap">
			<div class="flex items-center gap-2">
				<label
					for="route-select"
					class="text-sm font-medium text-slate-700 dark:text-slate-300"
				>
					Route:
				</label>
				<select
					id="route-select"
					class="px-3 py-2 rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 min-w-[280px]"
				>
					<option value="">— Select route —</option>
				</select>
			</div>
		</div>

		<div
			id="map-container"
			class="w-full h-[500px] rounded-lg overflow-hidden border border-slate-200 dark:border-slate-700"
		></div>
		<p id="status" class="text-sm text-slate-500 dark:text-slate-400">Loading…</p>

		<section
			id="route-info"
			class="rounded-lg border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-800/50 p-4 min-h-[80px] hidden"
		>
			<h2 class="text-sm font-semibold text-slate-700 dark:text-slate-300 mb-2">
				Trip info
			</h2>
			<div
				id="route-info-content"
				class="text-slate-600 dark:text-slate-400 text-sm space-y-1"
			></div>
		</section>

		<section class="mt-12 pt-8 border-t border-slate-200 dark:border-slate-700">
			<h2 class="text-xl font-semibold text-slate-900 dark:text-slate-100 mb-2">
				All routes
			</h2>
			<p class="text-slate-600 dark:text-slate-400 text-sm mb-4">
				All fetched routes displayed at once. Routes use alternating colors for visibility.
			</p>
			<div
				id="map-all-routes"
				class="w-full h-[500px] rounded-lg overflow-hidden border border-slate-200 dark:border-slate-700"
			></div>
		</section>

		<section class="mt-12 pt-8 border-t border-slate-200 dark:border-slate-700">
			<h2 class="text-xl font-semibold text-slate-900 dark:text-slate-100 mb-2">
				Route density
			</h2>
			<p class="text-slate-600 dark:text-slate-400 text-sm mb-4">
				Same routes with a single color and opacity. Roads used by more routes appear darker (overlapping segments accumulate).
			</p>
			<div
				id="map-route-density"
				class="w-full h-[500px] rounded-lg overflow-hidden border border-slate-200 dark:border-slate-700"
			></div>
		</section>
	</div>
</Layout>

<script>
	import { loadPreparedData, loadParquetData, loadIsochronesData } from '../data/load-prepared-data';
	import type { RoutesData, RouteData, RoutePairCount } from '../data/prepared-data-types';
	import type { IsochroneStation } from '../data/prepared-data-types';
	import { decodePolyline } from '../utils/decode-polyline';
	import { offsetPolyline } from '../utils/offset-polyline';
	import type { Map, LayerGroup } from 'leaflet';

	const base = import.meta.env.BASE_URL ?? '/';

	let map: Map | null = null;
	let stationDotsLayer: LayerGroup | null = null;
	let originMarkerLayer: LayerGroup | null = null;
	let destMarkerLayer: LayerGroup | null = null;
	const OSLO_CENTER: [number, number] = [59.92, 10.75];
	const DEFAULT_ZOOM = 13;
	const STATION_DOT_RADIUS = 6;
	const ARROW_COLOR = '#1a1a1a';
	const ROUTE_OFFSET_M = 12;
	const COLOR_FORWARD = '#22c55e';
	const COLOR_RETURN = '#3b82f6';
	const ALL_ROUTES_COLORS = [
		'#22c55e',
		'#3b82f6',
		'#f59e0b',
		'#8b5cf6',
		'#ec4899',
		'#06b6d4',
		'#ef4444',
	];

			function getBoundsForLayerGroup(
				L: typeof import('leaflet'),
				group: L.LayerGroup
			): L.LatLngBounds | null {
				const layers = group.getLayers();
				let bounds: L.LatLngBounds | null = null;
				for (const layer of layers) {
					const b = (layer as L.Polyline).getBounds?.();
					if (b?.isValid?.()) {
						if (!bounds) {
							bounds = L.latLngBounds(b.getSouthWest(), b.getNorthEast());
						} else {
							bounds.extend(b);
						}
					}
				}
				return bounds;
			}

			function addArrowDecorator(
		L: typeof import('leaflet'),
		layer: L.Polyline,
		group: L.LayerGroup,
		color = ARROW_COLOR
	) {
		try {
			const decorator = (L as any).polylineDecorator(layer, {
				patterns: [
					{
						offset: 0,
						repeat: 80,
						symbol: (L as any).Symbol.arrowHead({
							pixelSize: 12,
							polygon: true,
							pathOptions: {
								color,
								fillColor: color,
								fillOpacity: 1,
								weight: 1,
							},
						}),
					},
				],
			});
			decorator.addTo(group);
		} catch {
			// Plugin may not be loaded; skip arrows
		}
	}

	async function init() {
		const statusEl = document.getElementById('status');
		const selectEl = document.getElementById('route-select') as HTMLSelectElement;
		const mapEl = document.getElementById('map-container');
		const infoSection = document.getElementById('route-info');
		const infoContent = document.getElementById('route-info-content');
		if (!statusEl || !selectEl || !mapEl || !infoSection || !infoContent) return;

		const L = (await import('leaflet')).default;
		await import('leaflet-polylinedecorator');

		try {
			let stations: IsochroneStation[] = [];
			try {
				const { data } = await loadPreparedData<{ stations: IsochroneStation[] }>(
					'stations.json'
				);
				stations = data?.stations ?? [];
			} catch {
				const data = await loadIsochronesData();
				stations = data?.stations ?? [];
			}

			if (!stations.length) {
				statusEl.textContent =
					'No stations. Run stations_prepare.ipynb and npm run prepare:data.';
				return;
			}

			let routes: RouteData[] = [];
			try {
				const { data } = await loadPreparedData<RoutesData>('routes.json');
				routes = data?.routes ?? [];
			} catch {}

			const pairCountByKey = new Map<string, number>();
			try {
				const rows = await loadParquetData<RoutePairCount>('routes/route_pair_counts.parquet');
				for (const r of rows) {
					pairCountByKey.set(r.route_key, r.count);
				}
			} catch {
				// Parquet not yet generated; trip counts will be omitted
			}

			statusEl.textContent =
				routes.length === 0
					? 'No routes fetched yet. Run google_routes_test.ipynb and npm run prepare:data.'
					: '';

			const stationById = new Map(stations.map((s) => [s.id, s]));
			const routeByKey = new Map<string, RouteData>();
			for (const r of routes) {
				if (r.encodedPolyline) {
					routeByKey.set(`${r.origin_id}|${r.dest_id}`, r);
				}
			}

			for (const r of routes) {
				const origin = stationById.get(r.origin_id);
				const dest = stationById.get(r.dest_id);
				const label = origin && dest
					? `${origin.name} → ${dest.name}`
					: `${r.origin_id} → ${r.dest_id}`;
				const opt = document.createElement('option');
				opt.value = `${r.origin_id}|${r.dest_id}`;
				opt.textContent = label;
				selectEl.appendChild(opt);
			}

			map = L.map(mapEl).setView(OSLO_CENTER, DEFAULT_ZOOM);
			L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
				attribution:
					'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
			}).addTo(map);

			map.createPane('routePane');
			map.getPane('routePane')!.style.zIndex = '400';
			map.createPane('stationMarkersPane');
			map.getPane('stationMarkersPane')!.style.zIndex = '450';
			map.createPane('endpointsPane');
			map.getPane('endpointsPane')!.style.zIndex = '600';

			const routeGroup = L.layerGroup().addTo(map);
			stationDotsLayer = L.layerGroup().addTo(map);
			originMarkerLayer = L.layerGroup().addTo(map);
			destMarkerLayer = L.layerGroup().addTo(map);

			for (const s of stations) {
				const circle = L.circleMarker([s.lat, s.lon], {
					pane: 'stationMarkersPane',
					radius: STATION_DOT_RADIUS,
					fillColor: '#3b82f6',
					fillOpacity: 0.7,
					color: '#1e40af',
					weight: 1.5,
				});
				circle.bindTooltip(s.name, { permanent: false, direction: 'top' });
				circle.addTo(stationDotsLayer);
			}

			function formatDuration(sec: number | null) {
				return sec != null ? `${Math.round(sec / 60)} min` : 'N/A';
			}
			function formatDistance(m: number | null) {
				return m != null ? `${(m / 1000).toFixed(2)} km` : 'N/A';
			}

			function addRoutePolyline(
				route: RouteData,
				color: string,
				offsetM: number,
				originName: string,
				destName: string
			) {
				if (!route?.encodedPolyline) return;
				const points = decodePolyline(route.encodedPolyline).map(
					([lat, lng]) => [lat, lng] as [number, number]
				);
				const latlngs =
					offsetM !== 0 ? offsetPolyline(points, offsetM) : points;
				const poly = L.polyline(latlngs, {
					pane: 'routePane',
					color,
					weight: 5,
					opacity: 0.8,
				}).addTo(routeGroup);
				poly.on('mouseover', () => poly.setStyle({ weight: 8, opacity: 1 }));
				poly.on('mouseout', () => poly.setStyle({ weight: 5, opacity: 0.8 }));
				addArrowDecorator(L, poly, routeGroup, color);
				return poly;
			}

			function showRoute(routeKey: string) {
				routeGroup.clearLayers();
				originMarkerLayer?.clearLayers();
				destMarkerLayer?.clearLayers();

				const [originId, destId] = routeKey.split('|');
				const route = routeByKey.get(routeKey);
				if (!route?.encodedPolyline) return;

				const origin = stationById.get(originId);
				const dest = stationById.get(destId);
				const originName = origin?.name ?? originId;
				const destName = dest?.name ?? destId;

				const returnKey = `${destId}|${originId}`;
				const returnRoute = routeByKey.get(returnKey);

				addRoutePolyline(route, COLOR_FORWARD, 0, originName, destName);
				if (returnRoute) {
					addRoutePolyline(
						returnRoute,
						COLOR_RETURN,
						ROUTE_OFFSET_M,
						destName,
						originName
					);
				}

				const bounds = getBoundsForLayerGroup(L, routeGroup);
				if (bounds?.isValid()) map?.fitBounds(bounds, { padding: [30, 30] });

				const points = decodePolyline(route.encodedPolyline).map(
					([lat, lng]) => [lat, lng] as [number, number]
				);
				if (points.length > 0) {
					L.marker(points[0], { pane: 'endpointsPane' })
						.bindPopup(`Origin: ${originName}`)
						.addTo(originMarkerLayer!);
					L.marker(points[points.length - 1], { pane: 'endpointsPane' })
						.bindPopup(`Destination: ${destName}`)
						.addTo(destMarkerLayer!);
				}

				infoSection.classList.remove('hidden');
				const tripCount = pairCountByKey.get(routeKey);
				let html = `<p><strong>${originName}</strong> ↔ <strong>${destName}</strong></p>`;
				if (tripCount != null) {
					html += `<p class="mt-2">Total trips: <strong>${tripCount.toLocaleString()}</strong></p>`;
				}
				html += `<p class="mt-2"><strong>${originName}</strong> → ${destName}: ${formatDuration(route.duration_sec)} · ${formatDistance(route.distance_m)}</p>`;
				if (returnRoute) {
					html += `<p><strong>${destName}</strong> → ${originName}: ${formatDuration(returnRoute.duration_sec)} · ${formatDistance(returnRoute.distance_m)}</p>`;
				} else {
					html += `<p class="text-amber-600 dark:text-amber-400 italic">Return route (${destName} → ${originName}) not yet available.</p>`;
				}
				infoContent.innerHTML = html;
			}

			selectEl.addEventListener('change', () => {
				const val = selectEl.value;
				if (val) showRoute(val);
			});

			if (routes.length > 0) {
				selectEl.value = `${routes[0].origin_id}|${routes[0].dest_id}`;
				showRoute(selectEl.value);
			}

			// All-routes map
			const mapAllEl = document.getElementById('map-all-routes');
			if (mapAllEl && routes.length > 0) {
				const mapAll = L.map(mapAllEl).setView(OSLO_CENTER, DEFAULT_ZOOM);
				L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					attribution:
						'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
				}).addTo(mapAll);

				mapAll.createPane('allRoutePane');
				mapAll.getPane('allRoutePane')!.style.zIndex = '400';
				mapAll.createPane('allStationPane');
				mapAll.getPane('allStationPane')!.style.zIndex = '450';

				const allRouteGroup = L.layerGroup().addTo(mapAll);
				const allStationLayer = L.layerGroup().addTo(mapAll);

				for (const s of stations) {
					const circle = L.circleMarker([s.lat, s.lon], {
						pane: 'allStationPane',
						radius: 4,
						fillColor: '#64748b',
						fillOpacity: 0.6,
						color: '#475569',
						weight: 1,
					});
					circle.addTo(allStationLayer);
				}

				let allBounds: L.LatLngBounds | null = null;
				for (let i = 0; i < routes.length; i++) {
					const r = routes[i];
					if (!r?.encodedPolyline) continue;
					const points = decodePolyline(r.encodedPolyline).map(
						([lat, lng]) => [lat, lng] as [number, number]
					);
					const color = ALL_ROUTES_COLORS[i % ALL_ROUTES_COLORS.length];
					const poly = L.polyline(points, {
						pane: 'allRoutePane',
						color,
						weight: 3,
						opacity: 0.7,
					}).addTo(allRouteGroup);
					poly.on('mouseover', () => poly.setStyle({ weight: 5, opacity: 1 }));
					poly.on('mouseout', () => poly.setStyle({ weight: 3, opacity: 0.7 }));
					const origin = stationById.get(r.origin_id);
					const dest = stationById.get(r.dest_id);
					const label = origin && dest
						? `${origin.name} → ${dest.name}`
						: `${r.origin_id} → ${r.dest_id}`;
					poly.bindTooltip(label, { permanent: false, direction: 'top' });
					const b = poly.getBounds();
					if (b?.isValid?.()) {
						if (!allBounds) allBounds = L.latLngBounds(b.getSouthWest(), b.getNorthEast());
						else allBounds.extend(b);
					}
				}
				if (allBounds?.isValid()) {
					mapAll.fitBounds(allBounds, { padding: [40, 40] });
				}
			}

			// Route density map (opacity-based: overlapping = darker)
			const mapDensityEl = document.getElementById('map-route-density');
			if (mapDensityEl && routes.length > 0) {
				const mapDensity = L.map(mapDensityEl).setView(OSLO_CENTER, DEFAULT_ZOOM);
				L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					attribution:
						'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
				}).addTo(mapDensity);

				mapDensity.createPane('densityRoutePane');
				mapDensity.getPane('densityRoutePane')!.style.zIndex = '400';
				mapDensity.createPane('densityStationPane');
				mapDensity.getPane('densityStationPane')!.style.zIndex = '450';

				const densityRouteGroup = L.layerGroup().addTo(mapDensity);
				const densityStationLayer = L.layerGroup().addTo(mapDensity);

				for (const s of stations) {
					const circle = L.circleMarker([s.lat, s.lon], {
						pane: 'densityStationPane',
						radius: 4,
						fillColor: '#64748b',
						fillOpacity: 0.6,
						color: '#475569',
						weight: 1,
					});
					circle.addTo(densityStationLayer);
				}

				const DENSITY_COLOR = '#2563eb';
				const DENSITY_OPACITY = 0.35;
				let densityBounds: L.LatLngBounds | null = null;
				for (const r of routes) {
					if (!r?.encodedPolyline) continue;
					const points = decodePolyline(r.encodedPolyline).map(
						([lat, lng]) => [lat, lng] as [number, number]
					);
					const poly = L.polyline(points, {
						pane: 'densityRoutePane',
						color: DENSITY_COLOR,
						weight: 4,
						opacity: DENSITY_OPACITY,
					}).addTo(densityRouteGroup);
					poly.on('mouseover', () => poly.setStyle({ weight: 6, opacity: 0.7 }));
					poly.on('mouseout', () => poly.setStyle({ weight: 4, opacity: DENSITY_OPACITY }));
					const origin = stationById.get(r.origin_id);
					const dest = stationById.get(r.dest_id);
					const label = origin && dest
						? `${origin.name} → ${dest.name}`
						: `${r.origin_id} → ${r.dest_id}`;
					poly.bindTooltip(label, { permanent: false, direction: 'top' });
					const b = poly.getBounds();
					if (b?.isValid?.()) {
						if (!densityBounds) densityBounds = L.latLngBounds(b.getSouthWest(), b.getNorthEast());
						else densityBounds.extend(b);
					}
				}
				if (densityBounds?.isValid()) {
					mapDensity.fitBounds(densityBounds, { padding: [40, 40] });
				}
			}
		} catch (err) {
			statusEl.textContent = `Failed to load: ${err instanceof Error ? err.message : String(err)}`;
		}
	}

	init();
</script>
